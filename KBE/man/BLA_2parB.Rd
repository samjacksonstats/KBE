% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/BLA_2parB.r
\name{BLA_2parB}
\alias{BLA_2parB}
\title{Bayes Linear Adjustment by 2 Parallel Known Boundaries}
\usage{
BLA_2parB(
  x,
  K_d,
  L_d = 0,
  xK = NA,
  xL = NA,
  xLK = NA,
  xK_d = NA,
  xL_d = NA,
  fxK,
  fxL,
  fxLK,
  E_fx = 0,
  E_fxK = 0,
  E_fxL = 0,
  E_fxLK = 0,
  theta,
  s2
)
}
\arguments{
\item{x}{points at which we want to update}

\item{K_d}{the dimensions which, when fixed at certain values, result in known boundary K.}

\item{L_d}{the dimensions which, when fixed at certain values, result in known boundary L.}

\item{xK}{the projection of x onto known boundary K}

\item{xL}{the projection of x onto known boundary L}

\item{xLK}{the projection of x first onto known boundary L and then known boundary K.}

\item{xK_d}{values the dimensions K must take for the function to be known}

\item{xL_d}{values the dimensions L must take for the function to be known}

\item{fxK}{function evaluated at x projected onto the boundary K.}

\item{fxL}{function evaluated at x projected onto the boundary L.}

\item{fxLK}{function evaluated at xLK.}

\item{E_fx}{prior expectation for the function f(x)}

\item{E_fxK}{prior expectation for f(x^K)}

\item{E_fxL}{prior expectation for f(x^L)}

\item{E_fxLK}{prior expectation for f(x^LK)}

\item{theta}{vector of correlation length parameter values.}

\item{s2}{scalar variance parameter value.}
}
\value{
\item{EB_fx}{Expected value of f(x) adjusted by knowledge of function behaviour along K and L.}
\item{VarB_fx}{Variance of f(x) adjusted by knowledge of function behaviour along K and L.}
\item{CovB_fx}{Covariance of f(x) adjusted by knowledge of function behaviour along K and L.}
}
\description{
Perform a Bayes linear adjustment utilising knowledge of function behaviour along
two parallel known boundaries in the input space.
}
\examples{
# Toy function
f <- function( x ){

sin( x[1] / ( exp( x[2] ) ) ) + cos( x[3] )

}
x <- matrix( runif( 12 ), ncol = 3 )
K_d = 2
L_d = c(2,3)
xK_d = 0
xL_d = c(1,1)
# If we are in a parallel setting, then xLK (projection of x first onto L and then K)
# is given as follows:
xLK_d <- xL_d
xLK_d[1:length(xK_d)] <- xK_d
# And LK_d (fixed values of coordinates for projections first onto L and then K)
# is just given by L_d.
LK_d <- L_d
fxK <- f_boundary( x = x, K_d = K_d, xK_d = xK_d, f = f )
fxL <- f_boundary( x = x, K_d = L_d, xK_d = xL_d, f = f )
fxLK <- f_boundary( x = x, K_d = LK_d, xK_d = xLK_d, f = f )
theta <- c( pi, pi/8, pi )
s2 <- 2
BA <- BLA_2parB( x = x, K_d = K_d, L_d = L_d, xK_d = xK_d, xL_d = xL_d,
                  fxK = fxK, fxL = fxL, fxLK = fxLK, theta = theta, s2 = s2 )
}
